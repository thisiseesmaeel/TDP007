Uppgift 1:

Vår första fundering var ifall rexml skulle användas på första uppgiften. Eftersom att filen som fanns tillgänlig var i formatet av en textfil blev vi osäkra ifall en annan lösning var menad att användas, men när vi såg att det fanns taggar i filen valde vi att använda rexml streamlistener. Alla funktioner för streamlistener som användes hade tagits upp på föreläsningar så det var inget särskilt som vi behövde söka upp när det kom till rexml. Utöver rexml var det bara att skriva rätt logik för att lösa uppgiften. Vi valde att lägga varje rad inom taggen i en behållare (Rader som inte är fotbollslag togs bort med regex), på så sätt kan vi sedan använda sort_by funktionen för att sortera efter ett vilkor. För att kunna representera hela listan i slutet använde vi oss av join för att sätta ihop alla element i behållaren.

Programmet var väldigt enkelt att anpassa för weather.txt filen eftersom att programmet endast tar texten innanför taggarna och sorterar rad för rad. Det vi behövde ändra var regex sorteringen för filen och var i varje rad som sort_by funktionen skulle räkna. För att göra programmet ännu mer generellt valde vi att ta in två variabler i funktionerna least_diff och table_sort eftersom att funktionalliteten i funktionerna hade varit i stort sett identiska om vi hade skrivit separata funktioner för lösningen till weather.txt. 

Uppgift 2:

I uppgift två fanns det mycket utrymme för tolkning av uppgiften tyckte vi. Vi valde att ha två behållare där den ena endast innehåller alla event medans den andra innehåller alla datum med respektive event ifall det finns något. Vi ansåg att endast en behållare med event inte var särskilt praktiskt eftersom att man som användare säkert vill veta vilken dag det händer, så därför valde vi att göra båda behållare. Det finns säkert enklare sätt att lösa problemet på, lösningen är kanske inte så generell eftersom att den använder sig av mycket regex för att sortera ut data istället för att endast ta med data som ska vara med. Vi hittade ingen bättre lösning så vi valde att göra så. 

För att få en mer generell lösning hade det kanske varit bättre att läsa på mer om XML, SAX och XPath (som nämnt i uppgiften) men vi kände att lösningen vi kom fram till var tillräckligt bra. Vi hade problem ett tag med att få tag på två olika XPath's i samma loop och det slutade med att vi använde each-loopar för det mesta vilket kanske inte var det mest effektiva sättet att göra det på. Om vi hade läst på mer kanske vi hade hittat en bättre lösning.
